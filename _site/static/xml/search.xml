<?xml version="1.0" encoding="utf-8"?>
<ul>
  <li>什么是杂凑表杂凑表是由元素和标识符一一对应的字符串的一个集合。为什么要进行杂凑能够对一个数据序列的访问过程更加迅速有效，通过散列函数，元素能更快的进行定位。基本概念散列函数：给定关键字k，其值存放在f(k)的存储位置上，其中对应关系f，为散列函数。散列：映射过程。散列地址：散列函数所得的存储地址。冲突（碰撞）：对不同的关键字可能会得到相同的散列地址，即k1!=k2，而f(k1)=f(k2)。散列表：一个有限的连续的地址集合，将关键字k在地址集中的像作为记录在表中。装载因子：α=填入表中元素个数/表长。解决碰撞拉链法常用散列方法直接寻址法：除法杂凑：h(k)=kmodm乘法杂凑：m(kAmod1)取底全域杂凑：在一组杂凑函数中随机选取一个作为杂凑函数开放地址法：hi=(h(k)+di)modm,i=1,2,….,k&lt;=m-1.di为下列增量序列，有下列三种取法：线性探测二次探查双重探查课后习题1.在超大规模数组上实现直接寻址字典的解决方案2.假设用一个随机的散列函数来将n个不同的关键字杂凑到一个长度为m的数组中，预期的碰撞数为多少？即{(x,y):h(x)=h(y)}</li>
  <li>Web应用程序Web应用程序是一种可通过web访问的应用程序，有两种模式，C/S，B/S。C/S类型应用程序：Client客户端/Server服务器客户端必须安装专门的一个桌面软件才能使用。优点：速度快，安全性高，客户端比较强大缺点：每台客户端计算机都要下载安装升级，部署维护困难例如：QQ，各种网络游戏B/S类型应用程序：Browser浏览器/Server服务器客户端不用安装特定的软件，只要通过浏览器打开就可使用。优点：维护容易，只需要维护服务器缺点：速度慢，安全性相对较低，客户端较弱例如：WebQQ，各大网站，各种网页游戏Web应用程序开发过程分析设计实现选择一个框架开发打磨抛光发布和维护Web应用程序攻击关于Web应用程序攻击的一个很好的资源是：OpenWebApplicationSecurityProject（OWASP）。OWSAP的文档介绍了常见的漏洞类型，风险以及如何利用它们。要想进行渗透测试工作，需要了解OWASPtop10的方方面面。什么是Node？node.js，是基于ChromeV8引擎的JavaScript运行环境，使用了一个事件驱动，非阻塞式io的模型，轻量且高效。这里我的测试环境，使用Node.js作为应用程序的基础，Express框架作为Web服务器，并将Pug模板添加到此框架中。Express框架是一个Web框架，Pug正式名称为Jade，是一个服务器端模板引擎，以编程方式生成HTML页面，并发送给客户机。攻击工具Firefox，浏览器；Wappalyzer，BuiltWith，可揭示网站使用的技术；BurpSuite，OWASPZAP，渗透工具。网络探测扫描运行端口，网站目录和文件，子域名，网站漏洞。XSS跨站脚本攻击客户端攻击，允许攻击者创建特定的Web请求将恶意代码注入到响应中，可以通过输入验证来修复，但绝不是那么容易，从编码不规范到不理解框架，到应用程序过于复杂，都可能引起一个输入点的不安全性。</li>
  <li>什么是进程通信进程通信是指在进程间传输数据。进程通信根据交换信息量的多少和效率的高低，分为低级通信（只能传递状态和整数值）和高级通信（提高信号通信的效率，传递大量数据，减轻程序编制的复杂度）。其中高级进程通信分为三种方式：共享内存模式、消息传递模式、共享文件模式。为什么要进行进程通信为了提高计算机系统的效率；增强计算机系统内各种硬件的并行操作能力；操作系统要求程序结构必须适应并发处理的需要；进程是操作系统的核心，所有基于多道程序设计的操作系统都建立在进程的概念之上。目前的计算机系统均提供了多任务并行环境，无论是应用程序还是系统程序，都需要针对每一个任务创建相应的进程，进程是设计和分析操作系统的有力工具。然而不同的进程之间，即使是具有家族联系的父子进程，都具有各自不同的进程映像。由于不同的进程运行在各自不同的内存空间中，一方对于变量的修改另一方是无法感知的。因此，进程之间的信息传递不可能通过变量或其它数据结构直接进行，只能通过进程间通信来完成。并发进程之间的相互通信是实现多进程间协作和同步的常用工具，具有很强的实用性，进程通信是操作系统内核层极为重要的部分。基本进程通讯方法共享存储(间接通信)Shared-memory：相互通讯的进程有共享存储区。进程间可以通过直接读写共享存储区的变量来交互数据，同步与互斥在并发程序设计时安排进入程序。操作系统提供这样的共享存储区及同步互斥工具。最为快捷有效的方式之一，UNIX系统中常被使用。内存共享区的互斥要通过其它机制实现；数据的发送方不关心数据由谁接收，数据的接收方也不关心数据是由谁发送的，存在安全隐患。消息传递message-passing：通过操作系统的相应系统调用进行消息传递通讯。分为直接和间接两种：直接通信方式：点到点的发送Send(DestProcessName,Message)；Receive(SourceProcessName,Message)；基本思想：进程在发送和接收消息时直接指明接收者或发送者进程ID。缺点：必须指定接收进程ID。（UNIX的信号机制类似这种形式）间接通信方式：以信箱为媒介进行传递，可以广播Send(MailBox,Message)；Receive(MailBox,Message)；间接通信方式（信箱命名法）基本思想：系统为每个信箱设一个消息队列，消息发送和接收都指向该消息队列。缺点：必须有一个通讯双方共享的一个逻辑消息队列（UNIX的PIPE，FIFO及IPC消息传递机制都属于这种形式），使用时消息发送者约定写方式打开信箱,消息接受者约定读方式打开信箱或同时读写打开。优点：很容易建立双向通讯链(只要对信箱说明为读写打开)。管道通信是一种信息流缓冲机构，UNIX系统中管道基于文件系统，在内核中通过文件描述符表示。管道以先进先出(FIFO)方式组织数据传输。实现方法：调用pipe()函数创建管道intpipe(intfd[2]);fd[0]为管道里的读取端fd[1]则为管道的写入端。通过write()函数写入信息intwrite(inthandle,char*buf,unsignedlen)进程通过read()函数读取信息intread(inthandle,void*buf,unsignedlen)特点管道是一个单向通信信道，如果进程间要进行双向通信，通常需要定义两个管道。管道通过系统调用read(),write()函数进行读写操作。分类匿名管道：只适用于父子进程之间通信；管道能够把信息从一个进程的地址空间拷贝到另一个进程的地址空间。命名管道：命名管道有自己的名字和访问权限的限制，就像一个文件一样。它可以用于不相关进程间的通信，进程通过使用管道的名字获得管道。方式文件和记录锁定。为避免两个进程间同时要求访问同一共享资源而引起访问和操作的混乱，在进程对共享资源进行访问前必须对其进行锁定，该进程访问完后再释放。这是UNIX为共享资源提供的互斥性保障。管道。管道一般用于两个不同进程之间的通信。当一个进程创建一个管道，并调用fork创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。FIFO。FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO。因此也成为命名管。消息队列。UNIX下不同进程之间可实现共享资源的一种机制；UNIX允许不同进程将格式化的数据流以消息形式发送给任意进程。对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制。通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序。信号灯。作为进程间通讯的一种方法，它不是用于交换大批数据，而用于多进程之间的同步（协调对共享存储段的存取）。共享内存。通过信号灯实现存储共享（类似“红灯停、绿灯行”）</li>
  <li>什么是进程进程的概念是操作系统中最基本、最重要的概念。在多道程序系统（单处理器下并发运行多程序）出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律而引进的一个新概念：进程是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。为什么要引入进程刻画系统的动态性，发挥系统并发性，提高资源的利用率。解决共享性，正确描述程序（可再入）的执行状态。进程的控制处理器管理的一个重要工作就是对进程的控制：创建，阻塞，唤醒，挂起，激活，终止，撤销等。控制与管理由操作系统原语（若干条指令组成的程序段，用于执行特定功能，执行过程中不可被中断）来实现。创建子进程：在linux系统中，创建子进程方法有两种：fork（），创建进程后，子进程是父进程的一个拷贝，拥有相同的变量，打开的文件，但不共享任何内容。clone()，与fork()不同的是，允许定义共享内容。linux所做工作如下：将task_struct结构成员count加1，当父进程或子进程对虚存进行写操作的时候，给子进程的指针所指的数据结构分配内存。进程数缺省值计算方法：系统内存大小/内核栈大小/2，如内存有512M，则默认上限为：512*1024*1024/8192/2=32768。例子：#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;intmain(void){pid_tpid;char*message;intn;pid=fork();if(pid&lt;0){perror("forkfailed");exit(1);}if(pid==0){message="Thisisthechild\n";n=6;}else{message="Thisistheparent\n";n=3;}for(;n&gt;0;n--){printf(message);sleep(1);}return0;}执行如下：父进程初始化。父进程调用fork，这是一个系统调用，因此进入内核。内核根据父进程复制出一个子进程，父进程和子进程的PCB信息相同，用户态代码和数据也相同。因此，子进程现在的状态看起来和父进程一样，做完了初始化，刚调用了fork进入内核，还没有从内核返回。现在有两个一模一样的进程看起来都调用了fork进入内核等待从内核返回（实际上fork只调用了一次），此外系统中还有很多别的进程也等待从内核返回。是父进程先返回还是子进程先返回，还是这两个进程都等待，先去调度执行别的进程，这都不一定，取决于内核的调度算法。如果某个时刻父进程被调度执行了，从内核返回后就从fork函数返回，保存在变量pid中的返回值是子进程的id，是一个大于0的整数，因此执下面的else分支，然后执行for循环，打印”Thisistheparent\n”三次之后终止。如果某个时刻子进程被调度执行了，从内核返回后就从fork函数返回，保存在变量pid中的返回值是0，因此执行下面的if(pid==0)分支，然后执行for循环，打印”Thisisthechild\n”六次之后终止。fork调用把父进程的数据复制一份给子进程，但此后二者互不影响，在这个例子中，fork调用之后父进程和子进程的变量message和n被赋予不同的值，互不影响。父进程每打印一条消息就睡眠1秒，这时内核调度别的进程执行，在1秒这么长的间隙里（对于计算机来说1秒很长了）子进程很有可能被调度到。同样地，子进程每打印一条消息就睡眠1秒，在这1秒期间父进程也很有可能被调度到。所以程序运行的结果基本上是父子进程交替打印，但这也不是一定的，取决于系统中其它进程的运行情况和内核的调度算法，如果系统中其它进程非常繁忙则有可能观察到不同的结果。另外，读者也可以把sleep(1);去掉看程序的运行结果如何。这个程序是在Shell下运行的，因此Shell进程是父进程的父进程。父进程运行时Shell进程处于等待状态，当父进程终止时Shell进程认为命令执行结束了，于是打印Shell提示符，而事实上子进程这时还没结束，所以子进程的消息打印到了Shell提示符后面。最后光标停在Thisisthechild的下一行，这时用户仍然可以敲命令，即使命令不是紧跟在提示符后面，Shell也能正确读取。fork函数的特点概括起来就是“调用一次，返回两次”，在父进程中调用一次，在父进程和子进程中各返回一次。从上图可以看出，一开始是一个控制流程，调用fork之后发生了分叉，变成两个控制流程，这也就是“fork”（分叉）这个名字的由来了。子进程中fork的返回值是0，而父进程中fork的返回值则是子进程的id（从根本上说fork是从内核返回的，内核自有办法让父进程和子进程返回不同的值），这样当fork函数返回后，程序员可以根据返回值的不同让父进程和子进程执行不同的代码。阻塞进程和唤醒进程在linux系统中，与进程的阻塞和唤醒的相关原语有：sleep（暂停），pause（暂停等待信号），wait（等待进程暂停或终止），kill（发信号）。一个进程终止时，会关闭所有文件描述符，释放用户空间分配的内存，但PCB仍然保存着，内核在其中保存着一些信息。进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。waitpid例子：#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;intmain(void){pid_tpid;pid=fork();if(pid&lt;0){perror("forkfailed");exit(1);}if(pid==0){inti;for(i=3;i&gt;0;i--){printf("Thisisthechild\n");sleep(1);}exit(3);}else{intstat_val;waitpid(pid,&amp;stat_val,0);if(WIFEXITED(stat_val))printf("Childexitedwithcode%d\n",WEXITSTATUS(stat_val));elseif(WIFSIGNALED(stat_val))printf("Childterminatedabnormally,signal%d\n",WTERMSIG(stat_val));}return0;}执行如下：</li>
  <li>入侵电脑，窃听用户，假身份上网——美国安全公司HBGary是电脑防护和间谍软件的供应商。而其客户中就有美国的国家安全机构。现在，该公司被偷的电子邮件可以让我们对其数字化战争中的业务做一个初步了解。去年六月，美国安全公司HBGary的一名经理在美国联邦政府招标平台FBO.gov上发现了一个激动人心的项目：美国空军正在为一个所谓的“人事管理软件”寻找供应商。这一软件要能够让每个用户可以使用十个伪装身份上网。招标方对伪装身份的要求是：“必须可以让这些身份可以成为世界上任何地区的人。”而且即便是“富有经验的对手”也不能看出其在网上的详细信息是假的。简而言之：军方需要一套用来创建、管理和使用部队的数码信息的管理工具。出于什么目的尚不清楚。但可以想见几点：宣传、侦察、对使用假身份上网而暴露的人员提供保护。看到这则消息以后，这位HBGary经理马上跳了起来，立即通过电子邮件将这份招标信息的链接发送到几个同事的邮箱，并加了评论：“这是在公共网络上发布的招标，可能不是真的？”但是HBGary依然对其进行了投标。与美国情报机构良好的联系几个月后，互联网上的任何用户都能够看到这个消息以及HBGary的上万封邮件了——黑客盗窃了这家公司的数据。这场盗窃使网友们纷纷向HBGary扔来了板砖。黑客组织Anonymous称对这场数据盗窃负责。该组织曾闻名于维基解密捐款账户被封锁后对信用卡公司的黑客攻击。一位HBGary经理之前曾称，他知道Anonymous最重要的几位成员的身份。在该言论发布以后，匿名黑客搞定了HBGary几位经理的密码，偷了他们的电子邮件，攻陷了该公司的网页和数个Twitter账户。别看HBGary连自己的企业网络安全都存在漏洞，但千万不能低估它。该公司的电子邮件表明，HBGary的客户包括美国国土安全部和美国特种作战司令部。其几年前成立的子公司——联邦HBGary的几位经理曾任命于国防承包商诺斯罗普格鲁曼公司，并曾经和美国中央情报局、国家安全局和国防情报局的代表共事。间谍软件开发合同令专家惊讶其实，到目前为止，HBGary并非以间谍软件见长。据德国“明镜周刊在线”记者称，其采访过的很多数据安全专家都知道HBGary，并认为其技术是可靠的。HBGary比较闻名的主要是反间谍产品，尤其是响应者软件。这种工具被广泛用于检测电脑是否被恶意软件或嗅探软件攻击。根据该公司被公开的电子邮件，德国的刑事调查办公室也在使用他们的响应者软件。但是，HBGary不但提供防御类软件产品，也提供攻击性软件。德国鲁尔波鸿大学托斯特·霍尔茨(ThorstenHolz)教授是研究嵌入式恶意软件方面的专家。他用“颇受欢迎”这个词来形容该公司。在他看来，该公司的首席执行官格雷格·胡歌伦德(GregHoglund)是一位“Rootkit恶意软件专家”。胡歌伦德几年前曾与杰米·巴特勒(JamieButler)一起写过一本关于Rootkit研发的权威性著作。Rootkit是指主要功能为隐藏其他程式进程的软件，可能是一个或一个以上的软件组合。这使Rootkit具有广泛的操作性，令病毒扫描库等防御软件也不能将它识别出来。霍尔茨说，当然，防御性软件的开发者也需要从攻击者的角度来演示潜在的攻击，以便查找漏洞。然而，公司电子邮件的详细内容还是令他十分惊讶：“对我来说，这样的信息从来没听说过，HBGary居然也设计和出售Rootkit这样的攻击性软件。”委托任务：撬掉保护性软件，锁定文件在关于HBGary的消息中，有许多关于攻击性软件的方案。其中有些是该公司直接向客户提供的，如HBGary“Rootkit键盘记录平台”；而有些是该公司自2009年以来在军火商客户的委托下开发的。其项目代码名称各异，如“任务Z”、“项目C”、“12只猴子”或“一点红”，而这些形形色色的恶意软件无一例外地可以满足下列需求：l其中一个方案里写道：嗅探监测软件要能够记录键盘的录入情况，并按照特定关键字对电脑内的文件内容进行搜寻，并通过网络浏览器在普通数据传送时将搜寻到的数据捎带传回。l保证应用比较普遍的反Rootkit保护软件不能识别这一软件。l恶意软件在与有关管制单位交流互联网的网络流量情况时不受防火墙影响，并可以将其对外网的数据传输隐藏起来。l嗅探监测软件以不同的方式存在于电脑中，如网页、需要打开的文件、电子邮件以及传送的数据包。远距离访问Flash组件从目前的有关新闻描述看来，有些间谍软件组件的开发已经完成了。所以HBGary的经理们正在讨论，应该如何与国防承包商签订确定HBGary交付给对方的程序代码的使用范围的合同。他们讨论的对象正是“AdobeMacromediaFlashPlayer远程访问工具”(AdobeMacromediaFlashPlayerRemoteAccessTool)和“HBGaryRootkit键盘记录平台”(HBGaryRootkitKeyloggerPlatform)。从该公司被公布的电子邮件中无法看出，这些应用程序是否已经被使用以及在使用过程中取得了什么成果。专家对其技术设计的可行性做出了“合理”的评估结果。托斯特·霍尔茨评价道：“我所看过的联邦HBGary的软件建议从技术上来说是正确的。软件设计者所讨论和衡量的不同方法全都是有意义的。”监控和渗透社交网站2010年夏天，一位HBGary联邦经理对其同事讲述了在美国国家安全局的“社会媒体的弱点”会议上的一份报告。报告称，出于自己的目的，某些组织对网络保护手段以及将社会媒体作为启蒙宣传的工具有非常大的兴趣。比如“美国陆军情报和安全司令部”对这些手段就非常感兴趣。在内部邮件的交流中，HBGary的经理们主要讨论了安全软件的以下两种用途：l通过软件了对不同社交网的网络关系进行自动分析。l软件工具应该可以在社交网络上给虚拟身份添加相匹配的信息简介，并加以维护，以便给人“这一活跃在网上的虚拟人物确实存在”的印象，那么这种虚拟身份该如何使用呢？一位HBGary经理在一份构思中是这样描述的：可以分两个阶段对黑客集团进行渗透。首先要操控黑客所使用的软件，然后用另一个身份来揭露这一恶意操控，从而使前面的操控者暴露，这样来获得真正的黑客成员的信任。而如何对这一虚拟数码身份大军进行管理和维护，着实让这帮HBGary经理头疼。一位经理写道：“大部分将不得不通过软件工具来自动维护。”另一位经理回答说，他认识一位“在软件开发方面有多年的经验，熟知业务并掌握魔兽世界的很多故事和技术”的人。他指的是在线角色扮演游戏——魔兽世界中通过点击工具积累游戏币(目的是将其出售给玩家)。实践中的数字防控工业当然，所有这一切归根到底都是有关安全的买卖。而正如HBGary的经理们在邮件中所表现的，他们是非常积极的卖方。HBGary的经理们纷纷讨论，用什么样的解说能引起潜在客户的兴趣？到底存在什么样的人们认为的或者真正的危险？而如何才能借助这些危险来卖出他们的商品？什么样的报道会吸引观众？如何在各种会议和演示场所给人们留下正确的印象？可以用Rootkit恶意软件来打开或者关闭一台电脑的CD光驱吗？对实践中的数字防控工业小窥一斑，可以发现：当你开始觉着什么东西有可能的时候，可能已经有人在对其进行研发并寻找潜在客户了。</li>
</ul>