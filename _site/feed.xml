<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-01-25T18:01:16+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Gabe Blog</title><subtitle>Gabe的个人博客</subtitle><author><name>Gabe</name></author><entry><title type="html">Web应用程序漏洞利用</title><link href="http://localhost:4000/posts/2021/01/18/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8.html" rel="alternate" type="text/html" title="Web应用程序漏洞利用" /><published>2021-01-18T00:00:00+08:00</published><updated>2021-01-18T00:00:00+08:00</updated><id>http://localhost:4000/posts/2021/01/18/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8</id><content type="html" xml:base="http://localhost:4000/posts/2021/01/18/Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8.html">&lt;h3 id=&quot;web应用程序&quot;&gt;Web应用程序&lt;/h3&gt;

&lt;p&gt;Web应用程序是一种可通过web访问的应用程序，有两种模式，C/S，B/S。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;C/S类型应用程序：Client客户端/Server服务器&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;客户端必须安装专门的一个桌面软件才能使用。&lt;/p&gt;

    &lt;p&gt;优点：速度快，安全性高，客户端比较强大&lt;/p&gt;

    &lt;p&gt;缺点：每台客户端计算机都要下载安装升级，部署维护困难&lt;/p&gt;

    &lt;p&gt;例如：QQ，各种网络游戏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;B/S类型应用程序：Browser浏览器/Server服务器&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;客户端不用安装特定的软件，只要通过浏览器打开就可使用。&lt;/p&gt;

    &lt;p&gt;优点：维护容易，只需要维护服务器&lt;/p&gt;

    &lt;p&gt;缺点：速度慢，安全性相对较低，客户端较弱&lt;/p&gt;

    &lt;p&gt;例如：WebQQ，各大网站，各种网页游戏&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;web应用程序开发过程&quot;&gt;Web应用程序开发过程&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;分析&lt;/li&gt;
  &lt;li&gt;设计&lt;/li&gt;
  &lt;li&gt;实现选择一个框架&lt;/li&gt;
  &lt;li&gt;开发&lt;/li&gt;
  &lt;li&gt;打磨抛光&lt;/li&gt;
  &lt;li&gt;发布和维护&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;web应用程序攻击&quot;&gt;Web应用程序攻击&lt;/h3&gt;

&lt;p&gt;关于Web应用程序攻击的一个很好的资源是：Open Web Application Security Project（OWASP）。OWSAP的文档介绍了常见的漏洞类型，风险以及如何利用它们。要想进行渗透测试工作，需要了解OWASP top10的方方面面。&lt;/p&gt;

&lt;h4 id=&quot;什么是node&quot;&gt;什么是Node？&lt;/h4&gt;

&lt;p&gt;node.js，是基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动，非阻塞式io的模型，轻量且高效。&lt;/p&gt;

&lt;p&gt;这里我的测试环境，使用Node.js作为应用程序的基础，Express框架作为Web服务器，并将Pug模板添加到此框架中。&lt;/p&gt;

&lt;p&gt;Express框架是一个Web框架，Pug正式名称为Jade，是一个服务器端模板引擎，以编程方式生成HTML页面，并发送给客户机。&lt;/p&gt;

&lt;h4 id=&quot;攻击工具&quot;&gt;攻击工具&lt;/h4&gt;

&lt;p&gt;Firefox，浏览器；&lt;/p&gt;

&lt;p&gt;Wappalyzer，BuiltWith，可揭示网站使用的技术；&lt;/p&gt;

&lt;p&gt;BurpSuite，OWASP ZAP，渗透工具。&lt;/p&gt;

&lt;h4 id=&quot;网络探测&quot;&gt;网络探测&lt;/h4&gt;

&lt;p&gt;扫描运行端口，网站目录和文件，子域名，网站漏洞。&lt;/p&gt;

&lt;h4 id=&quot;xss跨站脚本攻击&quot;&gt;XSS跨站脚本攻击&lt;/h4&gt;

&lt;p&gt;客户端攻击，允许攻击者创建特定的Web请求将恶意代码注入到响应中，可以通过输入验证来修复，但绝不是那么容易，从编码不规范到不理解框架，到应用程序过于复杂，都可能引起一个输入点的不安全性。&lt;/p&gt;</content><author><name>Gabe</name></author><category term="CTF" /><summary type="html">Web应用程序</summary></entry><entry><title type="html">进程通信</title><link href="http://localhost:4000/posts/2020/11/18/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.html" rel="alternate" type="text/html" title="进程通信" /><published>2020-11-18T00:00:00+08:00</published><updated>2020-11-18T00:00:00+08:00</updated><id>http://localhost:4000/posts/2020/11/18/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1</id><content type="html" xml:base="http://localhost:4000/posts/2020/11/18/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.html">&lt;h4 id=&quot;什么是进程通信&quot;&gt;什么是进程通信&lt;/h4&gt;

&lt;p&gt;进程通信是指在进程间传输数据。&lt;/p&gt;

&lt;p&gt;进程通信根据交换信息量的多少和效率的高低，分为&lt;strong&gt;低级通信&lt;/strong&gt;（只能传递状态和整数值）和&lt;strong&gt;高级通信&lt;/strong&gt;（提高信号通信的效率，传递大量数据，减轻程序编制的复杂度）。&lt;/p&gt;

&lt;p&gt;其中高级进程通信分为三种方式：共享内存模式、消息传递模式、共享文件模式。&lt;/p&gt;

&lt;h4 id=&quot;为什么要进行进程通信&quot;&gt;为什么要进行进程通信&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;为了提高计算机系统的效率；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增强计算机系统内各种硬件的并行操作能力；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;操作系统要求程序结构必须适应并发处理的需要；&lt;/p&gt;

    &lt;p&gt;进程是操作系统的核心，所有基于多道程序设计的操作系统都建立在进程的概念之上。&lt;/p&gt;

    &lt;p&gt;目前的计算机系统均提供了多任务并行环境，无论是应用程序还是系统程序，都需要针对每一个任务创建相应的进程，进程是设计和分析操作系统的有力工具。&lt;/p&gt;

    &lt;p&gt;然而不同的进程之间，即使是具有家族联系的父子进程，都具有各自不同的进程映像。由于不同的进程运行在各自不同的内存空间中，一方对于变量的修改另一方是无法感知的。因此，进程之间的信息传递不可能通过变量或其它数据结构直接进行，只能通过进程间通信来完成。&lt;/p&gt;

    &lt;p&gt;并发进程之间的相互通信是实现多进程间协作和同步的常用工具，具有很强的实用性，进程通信是操作系统内核层极为重要的部分。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;基本进程通讯方法&quot;&gt;基本进程通讯方法&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;共享存储(间接通信)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Shared-memory：相互通讯的进程有共享存储区。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;进程间可以通过直接读写共享存储区的变量来交互数据，同步与互斥在并发程序设计时安排进入程序。操作系统提供这样的共享存储区及同步互斥工具。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;最为快捷有效的方式之一，UNIX系统中常被使用。内存共享区的互斥要通过其它机制实现；数据的发送方不关心数据由谁接收，数据的接收方也不关心数据是由谁发送的，存在安全隐患。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;消息传递&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;message-passing：通过操作系统的相应系统调用进行消息传递通讯。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;分为直接和间接两种：&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;直接通信方式：点到点的发送&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Send (DestProcessName, Message)；&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Receive (SourceProcessName, Message)；&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;基本思想：进程在发送和接收消息时直接指明接收者或发送者进程ID。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;缺点：必须指定接收进程ID。（UNIX的信号机制类似这种形式）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;间接通信方式：以信箱为媒介进行传递，可以广播&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Send (MailBox, Message)；&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Receive (MailBox, Message)；&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;间接通信方式（信箱命名法）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;基本思想：系统为每个信箱设一个消息队列，消息发送和接收都指向该消息队列。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;缺点：必须有一个通讯双方共享的一个逻辑消息队列（ UNIX的PIPE，FIFO及IPC消息传递机制都属于这种形式），使用时消息发送者约定写方式打开信箱,消息接受者约定读方式打开信箱或同时读写打开。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;优点：很容易建立双向通讯链(只要对信箱说明为读写打开)。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管道通信&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;是一种信息流缓冲机构， UNIX系统中管道基于文件系统，在内核中通过文件描述符表示。管道以先进先出(FIFO)方式组织数据传输。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;实现方法：&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;调用pipe()函数创建管道
int pipe(int fd[2]);&lt;/p&gt;

        &lt;p&gt;fd[0]为管道里的读取端&lt;/p&gt;

        &lt;p&gt;fd[1]则为管道的写入端。&lt;/p&gt;

        &lt;p&gt;通过write()函数写入信息&lt;/p&gt;

        &lt;p&gt;int write (int handle,char *buf,unsigned len)&lt;/p&gt;

        &lt;p&gt;进程通过read()函数读取信息&lt;/p&gt;

        &lt;p&gt;int read (int handle,void *buf,unsigned len)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;特点&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;管道是一个单向通信信道，如果进程间要进行双向通信，通常需要定义两个管道。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;管道通过系统调用read(), write()函数进行读写操作。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;分类&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;匿名管道：只适用于父子进程之间通信；管道能够把信息从一个进程的地址空间拷贝到另一个进程的地址空间。&lt;/li&gt;
          &lt;li&gt;命名管道：命名管道有自己的名字和访问权限的限制，就像一个文件一样。它可以用于不相关进程间的通信，进程通过使用管道的名字获得管道。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;方式&quot;&gt;方式&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;文件和记录锁定。
为避免两个进程间同时要求访问同一共享资源而引起访问和操作的混乱，在进程对共享资源进行访问前必须对其进行锁定，该进程访问完后再释放。这是UNIX为共享资源提供的互斥性保障。&lt;/li&gt;
  &lt;li&gt;管道。
管道一般用于两个不同进程之间的通信。当一个进程创建一个管道，并调用fork创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样 提供了两个进程之间数据流动的一种方式。&lt;/li&gt;
  &lt;li&gt;FIFO。
FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO。因此也成为命名管。&lt;/li&gt;
  &lt;li&gt;消息队列。
UNIX下不同进程之间可实现共享资源的一种机制；UNIX允许不同进程将格式化的数据流以消息形式发送给任意进程。对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制。通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序。&lt;/li&gt;
  &lt;li&gt;信号灯。
作为进程间通讯的一种方法，它不是用于交换大批数据，而用于多进程之间的同步（协调对共享存储段的存取）。&lt;/li&gt;
  &lt;li&gt;共享内存。
通过信号灯实现存储共享（类似“红灯停、绿灯行”）&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Gabe</name></author><category term="操作系统" /><summary type="html">什么是进程通信</summary></entry><entry><title type="html">进程控制</title><link href="http://localhost:4000/posts/2020/11/15/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.html" rel="alternate" type="text/html" title="进程控制" /><published>2020-11-15T00:00:00+08:00</published><updated>2020-11-15T00:00:00+08:00</updated><id>http://localhost:4000/posts/2020/11/15/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/posts/2020/11/15/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.html">&lt;h4 id=&quot;什么是进程&quot;&gt;什么是进程&lt;/h4&gt;

&lt;p&gt;进程的概念是操作系统中最基本、最重要的概念。在多道程序系统（单处理器下并发运行多程序）出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律而引进的一个新概念：&lt;/p&gt;

&lt;p&gt;进程是一个&lt;strong&gt;可并发执行&lt;/strong&gt;的具有&lt;strong&gt;独立功能&lt;/strong&gt;的程序关于&lt;strong&gt;某个数据集合&lt;/strong&gt;的一次&lt;strong&gt;执行过程&lt;/strong&gt;，也是操作系统进行资源分配和保护的基本单位。&lt;/p&gt;

&lt;h4 id=&quot;为什么要引入进程&quot;&gt;为什么要引入进程&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;刻画系统的动态性，发挥系统并发性，提高资源的利用率。&lt;/li&gt;
  &lt;li&gt;解决共享性，正确描述程序（可再入）的执行状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;进程的控制&quot;&gt;进程的控制&lt;/h4&gt;

&lt;p&gt;处理器管理的一个重要工作就是对进程的控制：创建，阻塞，唤醒，挂起，激活，终止，撤销等。&lt;/p&gt;

&lt;p&gt;控制与管理由操作系统原语（若干条指令组成的程序段，用于执行特定功能，执行过程中不可被中断）来实现。&lt;/p&gt;

&lt;h5 id=&quot;创建子进程&quot;&gt;创建子进程：&lt;/h5&gt;

&lt;p&gt;在linux系统中，创建子进程方法有两种：&lt;/p&gt;

&lt;p&gt;fork（），创建进程后，子进程是父进程的一个拷贝，拥有相同的变量，打开的文件，但不共享任何内容。&lt;/p&gt;

&lt;p&gt;clone() ，与fork()不同的是，允许定义共享内容。&lt;/p&gt;

&lt;p&gt;linux所做工作如下：将task_struct结构成员count加1，当父进程或子进程对虚存进行写操作的时候，给子进程的指针所指的数据结构分配内存。&lt;/p&gt;

&lt;p&gt;进程数缺省值计算方法：&lt;strong&gt;系统内存大小/内核栈大小/2&lt;/strong&gt;，如内存有512M，则默认上限为：512*1024*1024/8192/2=32768。&lt;/p&gt;

&lt;p&gt;例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fork failed&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;This is the child&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;This is the parent&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 		&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;Kali-2020-11-15-20-12-03.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;父进程初始化。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;父进程调用fork，这是一个系统调用，因此进入内核。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内核根据父进程复制出一个子进程，父进程和子进程的PCB信息相同，用户态代码和数据也相同。因此，子进程现在的状态看起来和父进程一样，做完了初始化，刚调用了fork进入内核，还没有从内核返回。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;现在有两个一模一样的进程看起来都调用了fork进入内核等待从内核返回（实际上fork只调用了一次），此外系统中还有很多别的进程也等待从内核返回。是父进程先返回还是子进程先返回，还是这两个进程都等待，先去调度执行别的进程，这都不一定，取决于内核的调度算法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果某个时刻父进程被调度执行了，从内核返回后就从fork函数返回，保存在变量pid中的返回值是子进程的id，是一个大于0的整数，因此执下面的else分支，然后执行for循环，打印”This is the parent\n”三次之后终止。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果某个时刻子进程被调度执行了，从内核返回后就从fork函数返回，保存在变量pid中的返回值是0，因此执行下面的if (pid == 0)分支，然后执行for循环，打印”This is thechild\n”六次之后终止。fork调用把父进程的数据复制一份给子进程，但此后二者互不影响，在这个例子中，fork调用之后父进程和子进程的变量message和n被赋予不同的值，互不影响。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;父进程每打印一条消息就睡眠1秒，这时内核调度别的进程执行，在1秒这么长的间隙里（对于计算机来说1秒很长了）子进程很有可能被调度到。同样地，子进程每打印一条消息就睡眠1秒，在这1秒期间父进程也很有可能被调度到。所以程序运行的结果基本上是父子进程交替打印，但这也不是一定的，取决于系统中其它进程的运行情况和内核的调度算法，如果系统中其它进程非常繁忙则有可能观察到不同的结果。另外，读者也可以把sleep(1);去掉看程序的运行结果如何。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个程序是在Shell下运行的，因此Shell进程是父进程的父进程。父进程运行时Shell进程处于等待状态，当父进程终止时Shell进程认为命令执行结束了，于是打印Shell提示符，而事实上子进程这时还没结束，所以子进程的消息打印到了Shell提示符后面。最后光标停在This is the child的下一行，这时用户仍然可以敲命令，即使命令不是紧跟在提示符后面，Shell也能正确读取。fork函数的特点概括起来就是“调用一次，返回两次”，在父进程中调用一次，在父进程和子进程中各返回一次。从上图可以看出，一开始是一个控制流程，调用fork之后发生了分叉，变成两个控制流程，这也就是“fork”（分叉）这个名字的由来了。子进程中fork的返回值是0，而父进程中fork的返回值则是子进程的id（从根本上说fork是从内核返回的，内核自有办法让父进程和子进程返回不同的值），这样当fork函数返回后，程序员可以根据返回值的不同让父进程和子进程执行不同的代码。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;阻塞进程和唤醒进程&quot;&gt;阻塞进程和唤醒进程&lt;/h5&gt;

&lt;p&gt;在linux系统中，与进程的阻塞和唤醒的相关原语有：sleep（暂停），pause（暂停等待信号），wait（等待进程暂停或终止），kill（发信号）。&lt;/p&gt;

&lt;p&gt;一个进程终止时，会关闭所有文件描述符，释放用户空间分配的内存，但PCB仍然保存着，内核在其中保存着一些信息。进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。&lt;/p&gt;

&lt;p&gt;waitpid例子：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pid_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fork failed&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;This is the child&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;waitpid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Child exited with code %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WIFSIGNALED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Child terminated abnormally, signal %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WTERMSIG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat_val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;Kali-2020-11-15-20-48-08.png&quot; alt=&quot;Picture&quot; /&gt;&lt;/p&gt;</content><author><name>Gabe</name></author><category term="操作系统" /><summary type="html">什么是进程</summary></entry></feed>